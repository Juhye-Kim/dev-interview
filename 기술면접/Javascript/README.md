## Javascript 질문 모음

1. 스코프란?
   > 식별자(변수, 함수, 클래스...)가 다른 코드에서 참조될 수 있는 유효 범위
   - js 엔진이 식별자를 찾을 때 검색하는 범위
   - 전역, 지역 스코프
     - 전역 : 어디서든 접근 가능한 범위
     - 지역 : block, function 스코프로 나뉨
   - js에서는 함수가 태어날 때, 내부슬롯에 상위 스코프에 대한 참조를 저장하고 태어남
2. function, block scope의 차이?

   > - fuctional scope : 함수를 기준으로 스코프 (범위)를 나눔 (var)
   > - block scope : 중괄호({ })를 기준으로 나눔 (let, const)

   - ex. for문에서 이 점을 주의해야한다. for문의 중괄호는 block scope라 초기화식에 var를 쓰면, function scope내에서 var로 선언된 변수가 변경되어 의도치 않은 결과가 나올 수도 있다.

3. lexical, dynamic scope의 차이점?

   > Lexical scope : 변수, 함수가 **선언된 곳**에 따라 정의되는 스코프

   - lexing time에 정의되는 스코프 (작성된 위치에 따라)
   - Static Scope라고도 함
   - ex. C/C++, Java, JavaScript 등 대부분의 언어들은 Lexical Scope를 사용

   > Dynamic Scope: 변수나 함수가 **호출된 곳**에 따라 정의되는 스코프

   - ex. Perl, Bash Shell, APL 등의 언어들이 사용

4. 호이스팅이란 무엇이고, 왜 일어나는지?
   > 코드 실행 보다 선언부가 먼저 `메모리`에 저장되는 과정
   - 변수, 함수가 스코프 최상단으로 끌어올려지듯이 보임
   - 선언문은 해당O, 할당은 해당X
   - 호이스팅 발생 이유
     - 변수 생성과 초기화(선언, 할당)가 따로 진행되기 때문
     - js는 코드가 실행되면 코드를 파싱하는데, 이때 전역 컨텍스트에 전역 변수 및 함수를 등록
     - 이때 코드를 해석해 변수, 함수 선언문을 코드의 상단으로 끌어올리는 효과가 발생
5. TDZ란?
   > let, const 로 선언한 변수가 **초기화**되기 전까지 대기하는곳
   - 선언부가 메모리에 저장될 때, var로 선언한 경우는 undefined로 초기화되는데, let, const로 선언되면 초기화가 되지 않음
     - 호이스팅은 되었지만, 초기화는 안된 상태!
     - 초기화 안되었는데 호출 → TDZ에서 대기중 → Reference error
   - TDZ는 선언 전에 변수를 사용하는 것을 허용X → 실수 방지에 도움
6. 전역 스코프 사용시 장단점은?

   - **장점**
     - Reference Error 안남
       - 정말 필요한 변수인 경우, 안전하게 사용 가능
   - **단점**
     - 코드 어디서든 참조가 가능해 의도치 않은 결과 발생
       - 동일 이름으로 만들면 큰일
     - 생명주기가 길어서 메모리 리소스도 오래 소비
       - 전역 변수 생명주기 = 전역객체 생명주기
       - 스코프 체인 상위에 존재해서, 변수 검색시 속도 느림

7. var, let, const 차이점?

   <img width="624" alt="스크린샷 2021-11-29 오후 8 00 14" src="https://user-images.githubusercontent.com/63178953/143856263-cf0fe9f7-11ad-416d-abbc-9213e9317ac2.png">

8. 클로저란 무엇인가요?

   > 함수와 함수가 선언된 어휘적 환경의 조합, 외부함수의 변수에 접근 가능한 내부함수

   - 외부함수보다 중첩함수가 더 오래 유지될 때, 이미 생명주기가 종료된 외부함수 변수를 참조할 수 있는 구조
     - 이미 실행 종료된 함수의 변수, 함수를 참조할 수 있는 내부함수
       - 외부함수 호출이 종료되어도 외부함수의 변수를 참조하거나, 스코프 체인 관계를 유지
   - 함수가 렉시컬 스코프를 기억하고 접근할 수 있는 특성
     - JS는 선언된 환경(렉시컬)을 기준으로 변수를 조회
     - 참조되고 있기 떄문에 가비지 컬렉션 대상이 되지 않음

9. 클로저를 사용한 경험, 혹은 예시는?
   > 의도치 않게 변경되지 않도록 은닉, 특정함수에게만 상태변경을 허용해서 안전하게 변경, 유지하기 위해 사용
   - ex. 모듈 패턴
     - 모듈 = 재사용 가능한 코드모음, 외부에서 접근 불가
   - ex. 커링패턴
   - ex. private 변수 (캡슐화)
     - 캡슐화 = 외부에서 접근할 수 없도록
     - 실제로 접근하지 못하도록
10. 클로저의 장단점?

    - 장점 : 모듈화, 은닉화
    - 단점 : 생명주기가 길어짐
      - 가비지컬렉터가 수거하게 하기
        - 참조끊기, 이벤트핸들러 → null로 없앰

11. 실행 컨텍스트란?
12. Lexical Environment란?
13. 일급객체(first-class citizen)란?
14. 콜백함수, 고차함수란?
