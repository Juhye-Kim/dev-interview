# 네트워크

1. OSI 7계층?

   > 네트워크 통신 과정을 단계별로 7개로 나눈것

   - 모듈화를 해두면, 문제 발생시 해당 부분만 고치면 해결이 수월해짐, 흐름 파악 용이
   - 7 (어플리케이션 계층)
     - 사용자와 인터랙션하는 응용 프로그램들이 포함된 계층
     - ex. HTTP, DNS, FTP, Telnet
   - 6 (표현 계층)

     - 데이터 포맷 정의, 압축/암호화 수행
     - ASCII, MPEG, JPEG, MIDI

   - 5 (세션 계층)
     - 통신중 연결 관리, 세션 열고, 닫고, 복구
   - 4 (transport(전송) 계층)
     - 프로세스에 데이터 전송
     - segmentation : 데이터를 세그먼트로 쪼김
     - 흐름제어, 오류제어
     - ex. TCP, UDP, ARP
   - 3 (네트워크 계층)
     - 네트워크 간 데이터 전송
     - routing : 패킷을 목적지까지 가장 빠른 길로 전송 (IP로)
     - ex. 라우터, IP
   - 2 (데이터링크 계층)
     - 네트워크 내 데이터 전송
     - framing : data본문 식별 위해 비트열로 감싸기
     - 오류제어 (이상한 frame은 버림), 흐름제어
     - ex. 스위치, 브릿지, MAC
   - 1 (물리 계층)
     - 데이터 → 전기신호로 변환
     - ex. 케이블, 허브, 리피터

1. TCP/IP 모델 4계층?

   - Network Interface : 물리계층 → 네트워크 하드웨어적으로 연결
     - 물리 + datalink
   - Network(Internet) : 패킷 처리, 다른 네트워크간 연결
     - Network
   - Transport : TCP/UDP
   - Application : 유저가 사용하는 서비스

1. TCP, UDP 방식의 차이점?

   > 둘다 트랜스포트 계층 프로토콜
   > **TCP**

   - 연결(보장)형 서비스, 3-way handshaking(서버-클라연결) 과정을 통해 연결
     → 높은 신뢰성을 보장, but 속도는 느린편
     → 웹, 이메일 등 HTTP 등 신뢰성이 중요한 통신에 쓰임
     **UDP**
   - 비연결형 서비스, 3-way handshaking을 사용하지 않음
     → 신뢰성이 떨어짐, but 수신 여부를 확인하지 않아 속도가 빠른편
     → DNS, 스트리밍 등 속도가 중요한 통신에 쓰임

1. TCP, UDP 탄생 배경?
   - IP는 Host to Host (장치 to 장치)만 지원
     - 장치 → 장치 이동은 IP로 해결되지만, 장치 내 여러 프로그램들이 통신할 때는 정보 부족
     - PORT번호로 해결
   - IP에서 오류 발생시 ICMP에서 알려줌
     - ICMP는 알려주기만 할 뿐 대처는 못함 → 상위에서 처리 필요
     - TCP/UDP가 해결
1. 3Way-HandShake, 4 Way-HandShake

   > 특별한 의미를 담은 플래그를 주고받음

   - **3 Way Handshake**

     - **TCP 통신을 하는 장치들이 연결을 맺는 과정**

     1. 클라 → 서버 : SYN(a) 접속시작알림
     2. 서버 → 클라 : ACK(a+1) ㅇㅋ, SYN(b) 나도시작
     3. 클라 → 서버 : ACK(b+1) 서버요청 수락

   - **4 Way-HandShake**
     - **TCP 통신을 하는 장치들이 연결을 종료하는 과정**
     1. 클라 → 서버 : FIN 연결종료
     2. 서버 → 클라 : ACK ㅇㅋ + TIME_OUT 데이터좀 마저 보낼게
     3. 서버 → 클라 : FIN 나도종료
     4. 클라 → 서버 : ACK ㅇㅋ
     5. 서버 : 소켓연결 닫음
     6. 클라 : TIME_WAIT 다안받았을수도 있으니 잠시 대기

1. DNS
   - DNS란?
     - Host의 Domain Name과 IP주소를 서로 변환해주는 서비스
       - IP 주소는 숫자인데, 기억하기 쉽도록 언어로 변환한게 도메인네임
       - DNS 서버들은 계층 구조로 이루어져있는데, Local DNS, Root, Top Level Domain(TLD), 서버 존재
         - 최상위 도메인부터 서브도메인.. 트리구조로 DNS서버를 찾음
   - CDN, GSLB, DNS의 차이점은?
     - **CDN (Content Delivery Network)**
       - 리소스를 다운로드할 수 있는 서버를 전세계에 분산시켜둠
         - 사용자에게 컨텐츠를 더 빠르게 제공할 수 있음
     - **GSLB (Global Server Load Balance)**
       - 사용자 컨텐츠요청에 대해 가장 최적의 서버환경을 찾아주는 역할
         - DNS의 발전된 형태
         - 서버 상태 알 수 있음 (정상만 찾음) - 라운드 방식 but 서버 트래픽 분석, 근접 서버 찾아냄
     - **DNS (Domain Name Service)**
       - 도메인 네임 → IP주소로 변환
       - 서버 상태를 알 수 없음 (정상인지 중단인지)
         - 라운드로빈 방식 → 떨어진 지역 서버와도 연결됨
1. proxy
   - proxy 서버가 필요한 이유?
     > 클라-서버 사이에 위치, 클라의 모든 요청을 서버에 전달
     1. 보안
        - 프록시 서버를 경유하면 IP를 숨길 수 있음
        - 프록시 서버를 방화벽으로 사용해 서버 직접 접근을 막음
     2. 캐시
        - 프록시 서버 중 일부는 요청된 내용을 Cache해두고, 같은 요청이 들어오면 서버에 접속하지 않고 Cache에 있는 리소스를 반환
     3. 접속 우회
        - 프록시 서버를 이용하면 접속을 다른나라로 우회할 수 있어 접속 제한 피할 수 있음
   - forward proxy, reverse proxy는?
     - **forward proxy**
       > 클라 요청을 대신전달
       - 클라가 서버로 요청할 때, 직접하지 않고 프록시 서버를 통해 요청
         - 서버에게 클라가 누군지 감추는 역할
         - 서버가 응답받은 IP는 포워드 프록시 서버의 IP라 클라가 누군지 모름
       - 기업 내부에서 많이 사용
         - 내부에서 외부로의 서비스 이용
         - 정해진 사이트만 연결되게 설정하는 등 웹 사용 환경 제한 가능
     - **reverse proxy**
       > 서버 응답을 대신전달
       - 클라가 요청할 때 리버스 프록시를 호출, 서버 응답을 클라이언트에게 전달
         - 서버가 누구인지 감추는 역할
         - 클라이언트는 리버스 프록시 서버를 먼저 호출 → 실제 서버 IP 모름
       - 외부에서 내부로의 서비스 이용
1. public IP, private IP 차이점?
   - **public IP**
     - 전세계에서 유일한 IP
     - ISP(인터넷 서비스 공급자)가 제공하는 IP주소
     - 외부 공개 → 인터넷에 연결된 다른 장비가 접근 가능
       - 방화벽 등 보안 설정 필요
   - **private IP**
     - 네트워크 내에서 사용되는 IP주소
       - IPV4 부족으로 모든 네트워크가 공인 IP를 사용하는 것이 불가능하기 때문에 네트워크 안에서 라우터를 통해 할당받는 가상 주소
     - 별도 설정 없이는 외부 접근 불가능
1. HTTP
   - HTTP 프로토콜에 대해 설명해주세요.
     - 서버-클라이언트가 웹페이지 데이터를 교환하기 위한 프로토콜
       - Method, Headers, Body, Path.. 로 구성
       - 애플리케이션 계층 프로토콜
     - **특징**
       - 비연결성
         - 클라-서버가 요청과 응답을 한번씩 주고받은 후 연결을 끊어 버리는 성질
           - 장점 : 연결 유지를 위한 리소스를 줄여 더 많은 연결 가능
           - 단점 : 연결/해제 오버헤드 발생
       - 무상태성 (Stateless)
         - 서버가 클라이언트 정보를 보존X → 식별하지 못하는 상태
           - 장점 : 각 서버는 클라이언트 정보가 모두 없는상태라, 응답하는 서버를 쉽게 바꿀 수 있음
           - 단점 : 클라이언트가 추가로 데이터 전송 필요
           - 쿠키, 세션, 토큰 등으로 해결
   - http1 vs http2
     - HTTP/1.1
       - 연결당 하나의 요청, 응답만 처리
         - 여러 개의 요청, 응답 한 번에 전송 불가
         - HTML 내 여러개의 리소스 요청, 응답은 개별적으로 전송됨
           - by \<link>, \<img>, \<script>..
       - 단점 : 요청할 리소스만큼 응답 시간도 증가
     - HTTP/2
       - 연결당 여러 개의 요청과 응답 처리 가능 (다중 요청/응답)
         - 여러 리소스 동시 전송 가능 → HTTP/1.1보다 페이지 로드 속도가 50% 정도 빠름
   - http1의 단점 보완하기 위한 노력? (서버로의 요청 줄이는 방법?)
     - 이미지 스프라이트
       - 이미지 파일들을 하나의 큰 이미지로 만들고, CSS에서 좌표 값을 지정해 각 이미지를 표시
     - css, js Minify
       - 데이터 용량을 줄이기 위해 CSS, Javascript를 축소해 적용
         - 불필요한 줄바꿈, 공백 밑 들여쓰기, 짧게 쓸 수 있는 긴 구문(줄일 수 있는 if 구문, 형 변환 축약 등), 스코프 내 사용하지 않는 변수, 주석
         - 경우에 따라, console.log, debugger 등의 디버깅용 구문 또는 메서드 호출
         - 경우에 따라, 무의미한 메서드 호출 및 루프
     - Data URI Scheme
       - 이미지 리소스를 Base64로 인코딩해 서버로의 요청을 줄임
     - Load Faster
       - 예전 : stylesheet는 HTML 상위에, script는 하단에 배치
       - 최신 : head에 js 삽입 + async, defer 키워드 사용
     - Domain Sharding
       - 요즘 브라우저들은 여러개의 Connection을 생성해 병렬로 요청을 보내기도 함
         - 도메인당 Connection의 개수 제한이 존재 → 근본적인 해결책은 아님
1. REST API
   - **REST**
     - HTTP URI → 리소스가 어떤 것인지
     - HTTP 메서드 → 그 리소스 어떻게 처리할지 명시
   - **REST API**
     - 이런 REST를 기반으로 서비스 API를 구현한 것
       ⇒ HTTP 요청시, 어떤 URI와 메서드를 쓸 지 개발자들끼리 널리 지키는 약속
       **기본규칙**
     - 동사 < 명사, 대문자 < 소문자
     - 자료에 따라 단/복수 구분
     - / 는 계층 관계 표시, 마지막에 안씀
     - 파일확장자X, -(O), \_(X)
   - GET, POST 메서드 차이점
     - GET : 기존 리소스를 조회하기 위한 요청
       - 데이터를 헤더에 담아 전송
       - URL에 데이터가 노출 → 민감한 데이터 포함X
     - POST : 새로운 리소스 생성, 수정
       - 데이터를 바디에 담아 전송
       - URL에 데이터가 노출되지 않아 GET보다는 안전
   - PUT, PATCH 메서드 차이점
     - PUT : 기존 리소스 전체 변경
       - 일부만 전달할 경우, 그외 필드들은 NULL or 초기값 처리
         - ex. 필드에 name, age, height 존재, 'name=DOBY'만 전달 → age, height는 0으로 초기화
     - PATCH : 기존 리소스 일부만 변경
1. HTTP 캐시
   - Expires, Date, Age, If-Modified-Since의 차이점
     - **Expires**
       - 엔티티 바디의 유효기간 (단위 : 날짜)
       - 엔티티 헤더 필드(응답/요청 다, 엔티티 정보)
     - **Date**
       - 메시지 생성 날짜
       - 일반 헤더 필드(응답/요청 다)
     - **Age**
       - 얼마나 오래전에 생성된 응답인지 (단위 : 초)
       - 응답 헤더 필드
     - **If-Modified-Since**
       - 클라가 이 헤더에 날짜를 지정해 보내면,
         서버는 리소스가 그 날짜 이후로 갱신된 경우에만 요청을 받아들임
         → 갱신되지 않았다면 304 Not Modified
       - 요청 헤더 필드
     - **Last-Modified**
       - 리소스의 최종 갱신 날짜
   - If-Modified-Since와 If-None-Match의 차이점
     - **If-Modified-Since**
       - 클라가 이 헤더에 날짜 지정해 보내면,
         서버는 리소스가 그 날짜 이후로 갱신된 경우에만 요청을 받아들임
     - **If-None-Match**
       - 필드값에 지정된 Etag값과 리소스Etag값이 일치하지 않으면 요청을 받아들임
         - Etag : 엔티티 태그, 리소스 식별자 (hash값)
1. IP, MAC 차이점?
   - IP는 한번 설정되면 변경되지 않음
   - MAC은 전송과정 중 계속 변경됨 (다음 라우터를 가리킴)
1. 흐름제어, 혼잡제어란?

   > TCP/IP의 신뢰성(= 데이터 유실 X)을 지키는 방법들

   - **흐름제어**
     - 송/수신측의 데이터 처리 속도 차이를 일치시킴 (End to End)
     - 데이터 전송량 차이 조절
     1. Stop and Wait
        - 패킷 보내고, ACK(확인응답) 받아야 그다음 패킷 보냄
     2. Sliding Window
        - 수신측이 설정한 window(버퍼크기) 크기만큼만 ACK확인없이 전송 가능
   - **혼잡제어**
     - 송신측의 데이터 전달 & 네트워크의 데이터 처리 속도 차이 조절
     - 혼잡도(네트워크 내 패킷 수)가 너무 크면, 송신측의 전송속도를 강제 제어

1. URI, URL, URN 에 대해 설명해주세요.

   - URI(Uniform Resource Identifier) : 인터넷 자원을 나타내는 고유 식별자
     - URN, URL은 URI에 포함된다.
   - URL - Locator: 리소스 위치
   - URN - Name: 리소스 이름
     - 위치는 변할 수 있지만, 이름은 변하지 않는다.

1. 브라우저 저장소에 대해 설명해주세요.

   - **Cookie, Web Storage**
     - 해당 도메인 관련 데이터를 브라우저에 저장할 수 있게 해주는 저장소
     - **Cookie**
       - 매번 서버로 전송됨 (서버-클라의 지속적인 데이터 교환을 위해 만들어짐)
       - 문자열만 가능, 용량 제한O, 만료 일자O
         ⇒ 이러한 부분들을 Web Storage로 극복가능
       - 4KB를 다 채운 쿠키는 계속 요청보내면 데이터 낭비일 수 있음
     - **Web Storage**
       - 데이터를 클라에 저장, 서버로는 전송X (CSRF 측면에서 쿠키보다 안전)
       - 객체로 저장, 용량 제한X
       - 지속성에 따라 구분
       - **LocalStorage**
         - 데이터를 명시적으로 지우지 않는한 영구 보관
         - origin 기준으로 공유
           - 도메인마다 별도로 생성, 도메인만 같다면 전역적으로 공유됨
         - ex. 자동 로그인
       - **SessionStorage**
         - 지속성, 액세스 범위가 제한적
         - 도메인마다 별도로 생성되는 점은 LocalStorage와 같지만,
           도메인이 같아도 브라우저가 다르면 서로 다른 영역으로 취급됨
           (브라우저 컨텍스트가 달라서)

1. url을 검색창에 쳤을 때 어떤 일들이 일어나나요?
   1. 브라우저가 url파싱 → 프로토콜, domain, port번호 분석
   2. HSTS (HTTP Strict Transport Security) 목록을 조회1`
      - 목록에 해당 url이 있으면 https로 요청 보내고, 아니면 http로 보냄
   3. URL → IP주소로 변환
      1. 로컬 hosts 파일, 브라우저 캐시 확인
      2. DNS에 요청해서 IP주소 찾음
         - Local DNS 없으면 rootDNS부터 계층적으로 요청해서 찾음
   4. ARP(Address Resolution Protocol)를 통해 IP → MAC주소로 변환
      - ARP : 네트워크 내에서 IP를 이용해 MAC주소를 알아내는 프로토콜
      - 네트워크 내에서 ARP를 브로드캐스팅 → 해당 IP주소를 가진 노드가 MAC주소 응답
   5. TCP통신 위해 연결을 진행
      - 3way handshake
      - https면 TLS handshake 추가
   6. 연결확정 후, HTTP 프토토콜로 서버에 요청하고, 응답받음
   7. 4way handshake로 응답종료
   8. 응답받은 리소스(html, css, js)... → DOM, CSSOM, Style, Layout, Paint, Composite..
